# -*- coding: utf-8 -*-
"""LOMBA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-aNG5isQYqcUtGC53pORwkNxqHwwKaxj
"""

import tensorflow as tf

# Memuat model menggunakan tf.keras
model = tf.keras.models.load_model('Best_Model_KRTMI.h5',compile=False)
classes = ['Daun', 'Kertas', 'Logam Ferro', 'Logam non-ferro', 'Plastik']

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
import time
# img = cv2.imread('photo.jpg')
# img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)

# photox = cv2.resize(img,(224, 224))
# photox.shape

# photoxx = tf.expand_dims(photox,axis=0)

# predict = model.predict(photoxx)

# predict1 = np.argmax(predict,axis=1)
# predict1 = predict1[0]
# predict_classes = clasess[predict1]
# predict_prob = predict[0][predict1]
# print(predict1,predict[0])

# import matplotlib.pyplot as plt

# plt.imshow(img)
# plt.title(f"Prediksi: {predict_classes}; Probability: {predict_prob:.2f}")
# plt.xticks([])
# plt.yticks([])
# plt.show()

# import cv2

# Buka feed video dari webcam
# Dictionary untuk menyimpan jumlah pengambilan gambar untuk setiap kelas
capture_count = {cls: 0 for cls in classes}

# Buka feed video dari webcam
cap = cv2.VideoCapture(0)  

# Periksa apakah feed video berhasil terbuka
if not cap.isOpened():
    print("Tidak dapat membuka kamera.")
    exit()

# Directory untuk menyimpan foto
save_dir = 'captured_photos'
if not os.path.exists(save_dir):
    os.makedirs(save_dir)

while True:
    # Baca frame dari feed video
    ret, frame = cap.read()

    # Proses frame (misalnya, resize ke ukuran yang diharapkan oleh model)
    processed_frame = cv2.resize(frame, (224, 224))  # Sesuaikan ukuran dengan model yang Anda gunakan

    # Lakukan prediksi pada frame yang telah diproses
    processed_frame = np.expand_dims(processed_frame, axis=0)  # Menambahkan dimensi batch
    predictions = model.predict(processed_frame)
    predicted_class_index = np.argmax(predictions, axis=1)[0]
    predicted_class = classes[predicted_class_index]
    predicted_prob = predictions[0][predicted_class_index]

    # Jika sampah terdeteksi, lakukan pengambilan gambar maksimal lima kali
    if predicted_class == 'Daun' and predicted_prob > 0.5:
        if capture_count['Daun'] < 5:
            # Simpan gambar
            file_name = os.path.join(save_dir, f"captured_{time.time()}.jpg")
            cv2.imwrite(file_name, frame)
            print(f"Foto terambil: {file_name}")
            # Update hitungan untuk kelas trash
            capture_count['Daun'] += 1
    if predicted_class == 'Kertas' and predicted_prob > 0.5:
        if capture_count['Kertas'] < 5:
            # Simpan gambar
            file_name = os.path.join(save_dir, f"captured_{time.time()}.jpg")
            cv2.imwrite(file_name, frame)
            print(f"Foto terambil: {file_name}")
            # Update hitungan untuk kelas trash
            capture_count['Kertas'] += 1
    if predicted_class == 'Plastik' and predicted_prob > 0.5:
        if capture_count['Plastik'] < 5:
            # Simpan gambar
            file_name = os.path.join(save_dir, f"captured_{time.time()}.jpg")
            cv2.imwrite(file_name, frame)
            print(f"Foto terambil: {file_name}")
            # Update hitungan untuk kelas trash
            capture_count['Plastik'] += 1
    if predicted_class == 'Logam Ferro' and predicted_prob > 0.5:
        if capture_count['Logam Ferro'] < 5:
            # Simpan gambar
            file_name = os.path.join(save_dir, f"captured_{time.time()}.jpg")
            cv2.imwrite(file_name, frame)
            print(f"Foto terambil: {file_name}")
            # Update hitungan untuk kelas trash
            capture_count['Logam Ferro'] += 1
    if predicted_class == 'Logam non-ferro' and predicted_prob > 0.5:
        if capture_count['Logam non-ferro'] < 5:
            # Simpan gambar
            file_name = os.path.join(save_dir, f"captured_{time.time()}.jpg")
            cv2.imwrite(file_name, frame)
            print(f"Foto terambil: {file_name}")
            # Update hitungan untuk kelas trash
            capture_count['Logam non-ferro'] += 1

    

    # Tampilkan hasil prediksi di atas frame webcam
    cv2.putText(frame, f"Prediction: {predicted_class}; Probability: {predicted_prob:.2f}",
                (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)

    # Tampilkan frame webcam
    cv2.imshow('Webcam', frame)

    # Tunggu tombol kunci 'q' untuk ditekan untuk keluar dari loop
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Bebaskan sumber daya
cap.release()
cv2.destroyAllWindows()